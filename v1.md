import React, { useState, useEffect, useRef } from 'react';
import { ArrowUp, ArrowDown, X, Check, RefreshCw, BarChart2, AlertTriangle } from 'lucide-react';

const TradingSignal = () => {
  // Danh sách các cặp giao dịch được hỗ trợ
  const supportedPairs = [
    { symbol: 'BTCUSDT', name: 'Bitcoin' },
    { symbol: 'THETAUSDT', name: 'Theta' },
    { symbol: 'SOLUSDT', name: 'Solana' },
    { symbol: 'ETHUSDT', name: 'Ethereum' },
    { symbol: 'BNBUSDT', name: 'BNB' }
  ];

  const [selectedSymbol, setSelectedSymbol] = useState('BTCUSDT');
  const [signalType, setSignalType] = useState('LONG'); // LONG hoặc SHORT
  type MarketData = {
    price: number;
    priceChangePercent: number;
    high24h: number;
    low24h: number;
    volume: number;
    lastUpdate: Date | null;
  };
  
  const [marketData, setMarketData] = useState<MarketData>({
    price: 0,
    priceChangePercent: 0,
    high24h: 0,
    low24h: 0,
    volume: 0,
    lastUpdate: null,
  });
  
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const historicalDataRef = useRef<{
    prices: {[timeframe: string]: number[][]},
    volumes: {[timeframe: string]: number[]},
  }>({
    prices: {
      '5m': [],
      '15m': [],
      '1h': [],
      '4h': [],
      '1d': [],
    },
    volumes: {
      '5m': [],
      '15m': [],
      '1h': [],
      '4h': [],
      '1d': [],
    }
  });
  
  // Dữ liệu phân tích cho từng cặp giao dịch
  type Analytics = {
    rsi: {[timeframe: string]: number};
    ema: {[timeframe: string]: number};
    macd: {
      line: number;
      signal: number;
      histogram: number;
    };
    bb: {
      upper: number;
      middle: number;
      lower: number;
    };
    vwap: number;
    entryRangeLow: number;
    entryRangeHigh: number;
    stopLoss: number;
    takeProfitOne: number;
    takeProfitTwo: number;
    whaleFlow: string;
    rvol: string;
    deltaVolume: number;
    orderBookPressure: string;
    takerFlowAggression: string;
    fundingRate: string;
    fundingTrend: string;
    oiDelta: string;
    atrVolatility: number;
    confidence: number;
    trends: { [key: string]: boolean };
    support4h: number[];
    support1d: number[];
    liquidations: { buy: number; sell: number };
    riskRewardRatio: { r1: number; r2: number };
    signalStrength: number;
    lastSignalTime: Date | null;
  };

  const [pairAnalytics, setPairAnalytics] = useState<Record<string, Analytics>>({
    'BTCUSDT': {
      rsi: {'5m': 42.18, '15m': 45.32, '1h': 47.65, '4h': 51.23, '1d': 55.78},
      ema: {'5m': 63150.45, '15m': 63180.75, '1h': 63250.45, '4h': 62980.75, '1d': 62750.25},
      macd: {
        line: 120.5,
        signal: 110.2,
        histogram: 10.3
      },
      bb: {
        upper: 64500.25,
        middle: 63250.45,
        lower: 62000.65
      },
      vwap: 63180.35,
      entryRangeLow: 62850.50,
      entryRangeHigh: 63350.25,
      stopLoss: 62100.00,
      takeProfitOne: 64200.00,
      takeProfitTwo: 65500.00,
      whaleFlow: 'Inflow > Outflow',
      rvol: '1.25x',
      deltaVolume: 2458.32,
      orderBookPressure: '2.15x',
      takerFlowAggression: '62.38%',
      fundingRate: '0.0021%',
      fundingTrend: '0.0018%',
      oiDelta: '0.12%',
      atrVolatility: 1250.50,
      confidence: 82,
      trends: { '5m': true, '15m': true, '1h': true, '4h': true, '1d': false },
      support4h: [61200, 64800],
      support1d: [58500, 66500],
      liquidations: { buy: 1250000, sell: 850000 },
      riskRewardRatio: { r1: 2.1, r2: 3.4 },
      signalStrength: 78,
      lastSignalTime: new Date(Date.now() - 1800000) // 30 minutes ago
    },
    'THETAUSDT': {
      rsi: {'5m': 58.75, '15m': 56.32, '1h': 54.65, '4h': 52.23, '1d': 48.78},
      ema: {'5m': 1.448, '15m': 1.450, '1h': 1.452, '4h': 1.438, '1d': 1.425},
      macd: {
        line: 0.003,
        signal: 0.001,
        histogram: 0.002
      },
      bb: {
        upper: 1.52,
        middle: 1.45,
        lower: 1.38
      },
      vwap: 1.447,
      entryRangeLow: 1.425,
      entryRangeHigh: 1.465,
      stopLoss: 1.38,
      takeProfitOne: 1.52,
      takeProfitTwo: 1.58,
      whaleFlow: 'Inflow > Outflow',
      rvol: '1.85x',
      deltaVolume: 1258432.45,
      orderBookPressure: '1.72x',
      takerFlowAggression: '59.12%',
      fundingRate: '0.0045%',
      fundingTrend: '0.0038%',
      oiDelta: '0.28%',
      atrVolatility: 0.085,
      confidence: 78,
      trends: { '5m': true, '15m': true, '1h': false, '4h': true, '1d': true },
      support4h: [1.32, 1.62],
      support1d: [1.15, 1.75],
      liquidations: { buy: 125000, sell: 95000 },
      riskRewardRatio: { r1: 2.5, r2: 3.8 },
      signalStrength: 72,
      lastSignalTime: new Date(Date.now() - 3600000) // 1 hour ago
    },
    'SOLUSDT': {
      rsi: {'5m': 27.52, '15m': 29.32, '1h': 32.65, '4h': 35.23, '1d': 38.78},
      ema: {'5m': 146.25, '15m': 146.58, '1h': 146.91, '4h': 147.82, '1d': 148.25},
      macd: {
        line: -0.85,
        signal: -0.35,
        histogram: -0.5
      },
      bb: {
        upper: 152.35,
        middle: 147.82,
        lower: 143.29
      },
      vwap: 146.75,
      entryRangeLow: 145.33,
      entryRangeHigh: 145.92,
      stopLoss: 144.17,
      takeProfitOne: 146.35,
      takeProfitTwo: 147.08,
      whaleFlow: 'Outflow > Inflow',
      rvol: '0.22x',
      deltaVolume: -413061.10,
      orderBookPressure: '1.50x',
      takerFlowAggression: '57.57%',
      fundingRate: '-0.0067%',
      fundingTrend: '-0.0053%',
      oiDelta: '-0.04%',
      atrVolatility: 0.985,
      confidence: 75,
      trends: { '5m': false, '15m': true, '1h': true, '4h': false, '1d': false },
      support4h: [140.25, 153.88],
      support1d: [95.19, 157.24],
      liquidations: { buy: 0, sell: 0 },
      riskRewardRatio: { r1: 1.8, r2: 2.7 },
      signalStrength: 65,
      lastSignalTime: new Date(Date.now() - 7200000) // 2 hours ago
    },
    'ETHUSDT': {
      rsi: {'5m': 45.32, '15m': 47.32, '1h': 48.65, '4h': 46.23, '1d': 49.78},
      ema: {'5m': 3048.75, '15m': 3050.25, '1h': 3052.45, '4h': 3048.75, '1d': 3035.25},
      macd: {
        line: 5.25,
        signal: 3.75,
        histogram: 1.5
      },
      bb: {
        upper: 3120.35,
        middle: 3052.45,
        lower: 2984.55
      },
      vwap: 3049.85,
      entryRangeLow: 3025.50,
      entryRangeHigh: 3075.25,
      stopLoss: 2980.00,
      takeProfitOne: 3120.00,
      takeProfitTwo: 3200.00,
      whaleFlow: 'Inflow > Outflow',
      rvol: '0.95x',
      deltaVolume: 1258.32,
      orderBookPressure: '1.85x',
      takerFlowAggression: '58.38%',
      fundingRate: '0.0011%',
      fundingTrend: '0.0008%',
      oiDelta: '0.08%',
      atrVolatility: 75.50,
      confidence: 70,
      trends: { '5m': true, '15m': false, '1h': true, '4h': true, '1d': false },
      support4h: [2950, 3150],
      support1d: [2800, 3250],
      liquidations: { buy: 450000, sell: 320000 },
      riskRewardRatio: { r1: 2.3, r2: 3.6 },
      signalStrength: 68,
      lastSignalTime: new Date(Date.now() - 5400000) // 1.5 hours ago
    },
    'BNBUSDT': {
      rsi: {'5m': 52.18, '15m': 53.32, '1h': 51.65, '4h': 49.23, '1d': 47.78},
      ema: {'5m': 576.25, '15m': 577.35, '1h': 578.45, '4h': 575.75, '1d': 572.25},
      macd: {
        line: 1.25,
        signal: 0.95,
        histogram: 0.3
      },
      bb: {
        upper: 590.35,
        middle: 578.45,
        lower: 566.55
      },
      vwap: 577.85,
      entryRangeLow: 572.50,
      entryRangeHigh: 582.25,
      stopLoss: 565.00,
      takeProfitOne: 590.00,
      takeProfitTwo: 605.00,
      whaleFlow: 'Inflow > Outflow',
      rvol: '1.05x',
      deltaVolume: 3258.32,
      orderBookPressure: '1.65x',
      takerFlowAggression: '56.38%',
      fundingRate: '0.0015%',
      fundingTrend: '0.0012%',
      oiDelta: '0.10%',
      atrVolatility: 12.50,
      confidence: 68,
      trends: { '5m': false, '15m': true, '1h': true, '4h': false, '1d': true },
      support4h: [560, 595],
      support1d: [540, 610],
      liquidations: { buy: 350000, sell: 280000 },
      riskRewardRatio: { r1: 2.0, r2: 3.2 },
      signalStrength: 62,
      lastSignalTime: new Date(Date.now() - 10800000) // 3 hours ago
    }
  });

  // Calculate RSI using real formula
  const calculateRSI = (prices: number[], periods = 14) => {
    if (prices.length < periods + 1) {
      return 50; // Default if not enough data
    }
    
    let gains = 0;
    let losses = 0;
    
    // First average gain/loss
    for (let i = 1; i <= periods; i++) {
      const difference = prices[i] - prices[i-1];
      if (difference >= 0) {
        gains += difference;
      } else {
        losses -= difference;
      }
    }
    
    let avgGain = gains / periods;
    let avgLoss = losses / periods;
    
    // Rest of the data using smoothing
    for (let i = periods + 1; i < prices.length; i++) {
      const difference = prices[i] - prices[i-1];
      
      if (difference >= 0) {
        avgGain = (avgGain * (periods - 1) + difference) / periods;
        avgLoss = (avgLoss * (periods - 1)) / periods;
      } else {
        avgGain = (avgGain * (periods - 1)) / periods;
        avgLoss = (avgLoss * (periods - 1) - difference) / periods;
      }
    }
    
    if (avgLoss === 0) {
      return 100;
    }
    
    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
  };

  // Calculate EMA using real formula
  const calculateEMA = (prices: number[], periods: number, previousEMA?: number) => {
    if (!previousEMA && prices.length < periods) {
      // Simple average if not enough data and no previous EMA
      return prices.reduce((sum, price) => sum + price, 0) / prices.length;
    }
    
    const multiplier = 2 / (periods + 1);
    
    if (!previousEMA) {
      // First EMA calculation is SMA
      const sma = prices.slice(0, periods).reduce((sum, price) => sum + price, 0) / periods;
      return sma;
    }
    
    // EMA = (Close - Previous EMA) * multiplier + Previous EMA
    return (prices[prices.length - 1] - previousEMA) * multiplier + previousEMA;
  };

  // Calculate MACD
  const calculateMACD = (prices: number[], fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) => {
    if (prices.length < Math.max(fastPeriod, slowPeriod) + signalPeriod) {
      return { line: 0, signal: 0, histogram: 0 };
    }
    
    const fastEMA = calculateEMA(prices, fastPeriod);
    const slowEMA = calculateEMA(prices, slowPeriod);
    const macdLine = fastEMA - slowEMA;
    
    // Calculate signal line (EMA of MACD line)
    const macdValues = [];
    for (let i = 0; i < prices.length - Math.max(fastPeriod, slowPeriod); i++) {
      const slicedPrices = prices.slice(0, Math.max(fastPeriod, slowPeriod) + i);
      const fastEMA = calculateEMA(slicedPrices, fastPeriod);
      const slowEMA = calculateEMA(slicedPrices, slowPeriod);
      macdValues.push(fastEMA - slowEMA);
    }
    
    const signalLine = calculateEMA(macdValues, signalPeriod);
    const histogram = macdLine - signalLine;
    
    return { line: macdLine, signal: signalLine, histogram };
  };

  // Calculate Bollinger Bands
  const calculateBollingerBands = (prices: number[], periods = 20, multiplier = 2) => {
    if (prices.length < periods) {
      return { upper: prices[prices.length-1] * 1.05, middle: prices[prices.length-1], lower: prices[prices.length-1] * 0.95 };
    }
    
    const slicedPrices = prices.slice(prices.length - periods);
    const sma = slicedPrices.reduce((sum, price) => sum + price, 0) / periods;
    
    // Calculate standard deviation
    const squaredDifferences = slicedPrices.map(price => Math.pow(price - sma, 2));
    const variance = squaredDifferences.reduce((sum, val) => sum + val, 0) / periods;
    const stdDev = Math.sqrt(variance);
    
    return {
      upper: sma + (multiplier * stdDev),
      middle: sma,
      lower: sma - (multiplier * stdDev)
    };
  };

  // Calculate VWAP (Volume Weighted Average Price)
  const calculateVWAP = (prices: number[][], volumes: number[]) => {
    if (prices.length === 0 || volumes.length === 0) {
      return 0;
    }
    
    let cumulativeTPV = 0; // Total Price * Volume
    let cumulativeVolume = 0;
    
    for (let i = 0; i < Math.min(prices.length, volumes.length); i++) {
      const typicalPrice = (prices[i][1] + prices[i][2] + prices[i][4]) / 3; // (High + Low + Close) / 3
      cumulativeTPV += typicalPrice * volumes[i];
      cumulativeVolume += volumes[i];
    }
    
    return cumulativeVolume === 0 ? prices[prices.length-1][4] : cumulativeTPV / cumulativeVolume;
  };

  // Calculate ATR (Average True Range)
  const calculateATR = (prices: number[][], periods = 14) => {
    if (prices.length < 2) {
      return 0;
    }
    
    const trueRanges = [];
    
    for (let i = 1; i < prices.length; i++) {
      const high = prices[i][2];
      const low = prices[i][3];
      const previousClose = prices[i-1][4];
      
      const tr1 = high - low;
      const tr2 = Math.abs(high - previousClose);
      const tr3 = Math.abs(low - previousClose);
      
      trueRanges.push(Math.max(tr1, tr2, tr3));
    }
    
    if (trueRanges.length < periods) {
      return trueRanges.reduce((sum, tr) => sum + tr, 0) / trueRanges.length;
    }
    
    // Use Wilder's smoothing method
    let atr = trueRanges.slice(0, periods).reduce((sum, tr) => sum + tr, 0) / periods;
    
    for (let i = periods; i < trueRanges.length; i++) {
      atr = ((atr * (periods - 1)) + trueRanges[i]) / periods;
    }
    
    return atr;
  };

  // Connect to WebSocket for real-time updates
  const connectWebSocket = () => {
    if (wsRef.current) {
      wsRef.current.close();
    }
    
    // Create a new WebSocket connection
    const ws = new WebSocket(`wss://stream.binance.com:9443/ws/${selectedSymbol.toLowerCase()}@trade/${selectedSymbol.toLowerCase()}@depth10@100ms`);
    
    ws.onopen = () => {
      console.log('WebSocket connected');
    };
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      // Handle trade data
      if (data.e === 'trade') {
        setMarketData(prev => ({
          ...prev,
          price: parseFloat(data.p),
          lastUpdate: new Date()
        }));
      }
      
      // Handle depth data
      if (data.e === 'depthUpdate') {
        // Calculate order book pressure
        let bidVolume = 0;
        let askVolume = 0;
        
        data.b.forEach((bid: string[]) => {
          bidVolume += parseFloat(bid[0]) * parseFloat(bid[1]);
        });
        
        data.a.forEach((ask: string[]) => {
          askVolume += parseFloat(ask[0]) * parseFloat(ask[1]);
        });
        
        const orderBookPressure = askVolume === 0 ? 99 : bidVolume / askVolume;
        
        // Update order book pressure
        updateOrderBookPressure(selectedSymbol, orderBookPressure);
      }
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      setError('WebSocket connection error. Falling back to REST API.');
      
      // Fallback to REST API
      fetchBinanceData();
    };
    
    ws.onclose = () => {
      console.log('WebSocket disconnected');
    };
    
    wsRef.current = ws;
    
    return () => {
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  };

  // Fetch historical data for technical indicators
  const fetchHistoricalData = async () => {
    try {
      const timeframes = ['5m', '15m', '1h', '4h', '1d'];
      const promises = timeframes.map(timeframe => 
        fetch(`https://api.binance.com/api/v3/klines?symbol=${selectedSymbol}&interval=${timeframe}&limit=100`)
          .then(res => res.json())
      );
      
      const results = await Promise.all(promises);
      
      // Process results
      results.forEach((data, index) => {
        const timeframe = timeframes[index];
        
        // Store candle data
        historicalDataRef.current.prices[timeframe] = data;
        
        // Extract volumes
        historicalDataRef.current.volumes[timeframe] = data.map((candle: any[]) => parseFloat(candle[5]));
        
        // Calculate technical indicators
        const closePrices = data.map((candle: any[]) => parseFloat(candle[4]));
        
        // Calculate RSI
        const rsi = calculateRSI(closePrices, timeframe === '1d' ? 14 : timeframe === '4h' ? 14 : timeframe === '1h' ? 14 : 14);
        
        // Calculate EMAs
        const ema = calculateEMA(
          closePrices, 
          timeframe === '1d' ? 21 : timeframe === '4h' ? 21 : timeframe === '1h' ? 21 : timeframe === '15m' ? 21 : 21,
          pairAnalytics[selectedSymbol]?.ema[timeframe]
        );
        
        // Update analytics with calculated values
        setPairAnalytics(prev => ({
          ...prev,
          [selectedSymbol]: {
            ...prev[selectedSymbol],
            rsi: {
              ...prev[selectedSymbol].rsi,
              [timeframe]: parseFloat(rsi.toFixed(2))
            },
            ema: {
              ...prev[selectedSymbol].ema,
              [timeframe]: parseFloat(ema.toFixed(selectedSymbol === 'BTCUSDT' ? 2 : 4))
            }
          }
        }));
      });
      
      // Calculate additional indicators using the 1h data
      const data1h = results[2]; // 1h data
      if (data1h && data1h.length > 0) {
        const closePrices = data1h.map((candle: any[]) => parseFloat(candle[4]));
        const highPrices = data1h.map((candle: any[]) => parseFloat(candle[2]));
        const lowPrices = data1h.map((candle: any[]) => parseFloat(candle[3]));
        const volumes = data1h.map((candle: any[]) => parseFloat(candle[5]));
        
        // Calculate MACD
        const macd = calculateMACD(closePrices);
        
        // Calculate Bollinger Bands
        const bb = calculateBollingerBands(closePrices);
        
        // Calculate VWAP
        const vwap = calculateVWAP(data1h, volumes);
        
        // Calculate ATR
        const atr = calculateATR(data1h);
        
        // Update analytics with additional indicators
        setPairAnalytics(prev => ({
          ...prev,
          [selectedSymbol]: {
            ...prev[selectedSymbol],
            macd: {
              line: parseFloat(macd.line.toFixed(selectedSymbol === 'BTCUSDT' ? 2 : 4)),
              signal: parseFloat(macd.signal.toFixed(selectedSymbol === 'BTCUSDT' ? 2 : 4)),
              histogram: parseFloat(macd.histogram.toFixed(selectedSymbol === 'BTCUSDT' ? 2 : 4))
            },
            bb: {
              upper: parseFloat(bb.upper.toFixed(selectedSymbol === 'BTCUSDT' ? 2 : 4)),
              middle: parseFloat(bb.middle.toFixed(selectedSymbol === 'BTCUSDT' ? 2 : 4)),
              lower: parseFloat(bb.lower.toFixed(selectedSymbol === 'BTCUSDT' ? 2 : 4))
            },
            vwap: parseFloat(vwap.toFixed(selectedSymbol === 'BTCUSDT' ? 2 : 4)),
            atrVolatility: parseFloat(atr.toFixed(selectedSymbol === 'BTCUSDT' ? 2 : 4))
          }
        }));
      }
      
    } catch (err) {
      console.error('Error fetching historical data:', err);
      setError('Failed to fetch historical data for technical indicators.');
    }
  };

  // Fetch data from Binance API
  const fetchBinanceData = async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Fetch ticker price
      const tickerResponse = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${selectedSymbol}`);
      if (!tickerResponse.ok) throw new Error('Failed to fetch ticker data');
      
      const tickerData = await tickerResponse.json();
      
      // Update market data
      setMarketData({
        price: parseFloat(tickerData.lastPrice),
        priceChangePercent: parseFloat(tickerData.priceChangePercent),
        high24h: parseFloat(tickerData.highPrice),
        low24h: parseFloat(tickerData.lowPrice),
        volume: parseFloat(tickerData.volume),
        lastUpdate: new Date()
      });
      
      // Fetch historical data for technical indicators
      await fetchHistoricalData();
      
      // Calculate entry, stop loss, and take profit levels
      updateTradeParameters(selectedSymbol, parseFloat(tickerData.lastPrice));
      
      // Fetch order book to calculate pressure
      const orderBookResponse = await fetch(`https://api.binance.com/api/v3/depth?symbol=${selectedSymbol}&limit=100`);
      if (orderBookResponse.ok) {
        const orderBookData = await orderBookResponse.json();
        
        // Calculate order book pressure (bid vs ask volume)
        const bidVolume = orderBookData.bids.reduce((sum: number, bid: string[]) => sum + (parseFloat(bid[0]) * parseFloat(bid[1])), 0);
        const askVolume = orderBookData.asks.reduce((sum: number, ask: string[]) => sum + (parseFloat(ask[0]) * parseFloat(ask[1])), 0);
        
        const orderBookPressure = askVolume === 0 ? 99 : bidVolume / askVolume;
        
        // Update order book pressure
        updateOrderBookPressure(selectedSymbol, orderBookPressure);
      }
      
      // Fetch funding rate for futures
      try {
        const fundingResponse = await fetch(`https://fapi.binance.com/fapi/v1/fundingRate?symbol=${selectedSymbol}&limit=1`);
        if (fundingResponse.ok) {
          const fundingData = await fundingResponse.json();
          if (fundingData.length > 0) {
            updateFundingRate(selectedSymbol, parseFloat(fundingData[0].fundingRate) * 100);
          }
        }
      } catch (fundingErr) {
        // Ignore funding rate errors, not critical
        console.log('Funding rate fetch failed, might not be a futures market');
      }
      
      // Calculate signal strength and update confidence
      updateSignalStrength(selectedSymbol);
      
    } catch (err) {
      console.error('Error fetching data:', err);
      setError('Failed to fetch market data. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  // Update trade parameters (entry, stop loss, take profit)
  const updateTradeParameters = (symbol: string, currentPrice: number) => {
    const analytics = {...pairAnalytics[symbol]};
    const atr = analytics.atrVolatility;
    
    // Use ATR for dynamic ranges instead of fixed percentages
    if (signalType === 'LONG') {
      // For LONG positions
      analytics.entryRangeLow = parseFloat((currentPrice - 0.5 * atr).toFixed(symbol === 'BTCUSDT' ? 2 : 4));
      analytics.entryRangeHigh = parseFloat((currentPrice + 0.2 * atr).toFixed(symbol === 'BTCUSDT' ? 2 : 4));
      
      // Dynamic stop loss based on ATR
      analytics.stopLoss = parseFloat((currentPrice - 2 * atr).toFixed(symbol === 'BTCUSDT' ? 2 : 4));
      
      // Take profit levels based on risk-reward ratios
      const risk = currentPrice - analytics.stopLoss;
      analytics.takeProfitOne = parseFloat((currentPrice + risk * analytics.riskRewardRatio.r1).toFixed(symbol === 'BTCUSDT' ? 2 : 4));
      analytics.takeProfitTwo = parseFloat((currentPrice + risk * analytics.riskRewardRatio.r2).toFixed(symbol === 'BTCUSDT' ? 2 : 4));
    } else {
      // For SHORT positions
      analytics.entryRangeLow = parseFloat((currentPrice - 0.2 * atr).toFixed(symbol === 'BTCUSDT' ? 2 : 4));
      analytics.entryRangeHigh = parseFloat((currentPrice + 0.5 * atr).toFixed(symbol === 'BTCUSDT' ? 2 : 4));
      
      // Dynamic stop loss based on ATR
      analytics.stopLoss = parseFloat((currentPrice + 2 * atr).toFixed(symbol === 'BTCUSDT' ? 2 : 4));
      
      // Take profit levels based on risk-reward ratios
      const risk = analytics.stopLoss - currentPrice;
      analytics.takeProfitOne = parseFloat((currentPrice - risk * analytics.riskRewardRatio.r1).toFixed(symbol === 'BTCUSDT' ? 2 : 4));
      analytics.takeProfitTwo = parseFloat((currentPrice - risk * analytics.riskRewardRatio.r2).toFixed(symbol === 'BTCUSDT' ? 2 : 4));
    }
    
    // Update support/resistance levels based on Bollinger Bands and historical pivots
    analytics.support4h = [
      parseFloat((analytics.bb.lower).toFixed(symbol === 'BTCUSDT' ? 2 : 4)),
      parseFloat((analytics.bb.upper).toFixed(symbol === 'BTCUSDT' ? 2 : 4))
    ];
    
    // Update pairAnalytics
    setPairAnalytics((prev) => ({
      ...prev,
      [symbol]: analytics
    }));
  };
  
  // Update order book pressure
  const updateOrderBookPressure = (symbol: string, pressure: number) => {
    setPairAnalytics((prev) => ({
      ...prev,
      [symbol]: {
        ...prev[symbol],
        orderBookPressure: pressure.toFixed(2) + 'x',
        takerFlowAggression: (pressure > 1 ? 
          (50 + Math.min(pressure * 5, 30)).toFixed(2) : 
          (50 - Math.min((1/pressure) * 5, 30)).toFixed(2)) + '%'
      }
    }));
  };
  
  // Update funding rate
  const updateFundingRate = (symbol: string, rate: number) => {
    // Get historical funding rates to determine trend
    const fundingTrend = rate * 0.85; // Simplified, ideally would use actual historical data
    
    setPairAnalytics((prev) => ({
      ...prev,
      [symbol]: {
        ...prev[symbol],
        fundingRate: rate.toFixed(4) + '%',
        fundingTrend: fundingTrend.toFixed(4) + '%',
        // Update OI delta based on funding rate changes
        oiDelta: ((rate - fundingTrend) * 10).toFixed(2) + '%'
      }
    }));
  };
  
  // Calculate and update signal strength
  const updateSignalStrength = (symbol: string) => {
    const analytics = pairAnalytics[symbol];
    
    // Multi-timeframe confirmation
    const timeframes = ['5m', '15m', '1h', '4h', '1d'];
    let timeframeConfirmations = 0;
    
    timeframes.forEach(tf => {
      const isLongSignal = signalType === 'LONG';
      const rsiConfirms = isLongSignal ? 
        (analytics.rsi[tf] < 40 && analytics.rsi[tf] > 20) : // Oversold but not extremely
        (analytics.rsi[tf] > 60 && analytics.rsi[tf] < 80);  // Overbought but not extremely
      
      const emaConfirms = isLongSignal ?
        (analytics.ema[tf] < marketData.price) : // Price above EMA for long
        (analytics.ema[tf] > marketData.price);  // Price below EMA for short
      
      if (rsiConfirms && emaConfirms) {
        timeframeConfirmations++;
      }
    });
    
    // MACD confirmation
    const macdConfirms = signalType === 'LONG' ?
      (analytics.macd.histogram > 0 && analytics.macd.histogram > analytics.macd.histogram) :
      (analytics.macd.histogram < 0 && analytics.macd.histogram < analytics.macd.histogram);
    
    // Bollinger Bands confirmation
    const bbConfirms = signalType === 'LONG' ?
      (marketData.price < analytics.bb.lower * 1.01) : // Price near lower band for long
      (marketData.price > analytics.bb.upper * 0.99); // Price near upper band for short
    
    // Volume confirmation
    const volumeConfirms = parseFloat(analytics.rvol) > 1.2;
    
    // Order book pressure confirmation
    const obConfirms = signalType === 'LONG' ?
      (parseFloat(analytics.orderBookPressure) > 1.2) :
      (parseFloat(analytics.orderBookPressure) < 0.8);
    
    // Whale flow confirmation
    const whaleConfirms = signalType === 'LONG' ?
      analytics.whaleFlow.includes('Inflow > Outflow') :
      analytics.whaleFlow.includes('Outflow > Inflow');
    
    // Calculate overall signal strength (0-100)
    const signalStrength = (
      (timeframeConfirmations / timeframes.length) * 40 + // 40% weight to timeframe confirmations
      (macdConfirms ? 15 : 0) +                          // 15% weight to MACD
      (bbConfirms ? 10 : 0) +                            // 10% weight to Bollinger Bands
      (volumeConfirms ? 10 : 0) +                        // 10% weight to volume
      (obConfirms ? 15 : 0) +                            // 15% weight to order book
      (whaleConfirms ? 10 : 0)                           // 10% weight to whale flow
    );
    
    // Update confidence based on signal strength
    const confidence = Math.min(Math.max(Math.round(signalStrength), 0), 100);
    
    setPairAnalytics((prev) => ({
      ...prev,
      [symbol]: {
        ...prev[symbol],
        signalStrength: parseFloat(signalStrength.toFixed(1)),
        confidence,
        // Update last signal time if confidence is high enough and changed significantly
        lastSignalTime: confidence > 75 && Math.abs(confidence - prev[symbol].confidence) > 10 ?
          new Date() : prev[symbol].lastSignalTime
      }
    }));
  };
  
  // Initialize WebSocket connection and fetch data on component mount
  useEffect(() => {
    fetchBinanceData();
    connectWebSocket();
    
    // Set up interval to fetch additional data every 60 seconds
    // WebSocket handles real-time price updates, but we still need to refresh other data
    const intervalId = setInterval(() => {
      fetchHistoricalData();
    }, 60000);
    
    // Clean up interval and WebSocket on component unmount
    return () => {
      clearInterval(intervalId);
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, [selectedSymbol, signalType]);
  
  // Format number with thousands separator
  const formatNumber = (num: number, decimals = 2) => {
    return num?.toLocaleString(undefined, { minimumFractionDigits: decimals, maximumFractionDigits: decimals }) || '0';
  };
  
  // Format large numbers with K, M, B suffix
  const formatLargeNumber = (num: number) => {
    if (num >= 1000000000) {
      return (num / 1000000000).toFixed(2) + 'B';
    } else if (num >= 1000000) {
      return (num / 1000000).toFixed(2) + 'M';
    } else if (num >= 1000) {
      return (num / 1000).toFixed(2) + 'K';
    }
    return num.toFixed(2);
  };
  
  // Get current analytics for selected pair
  const currentAnalytics = pairAnalytics[selectedSymbol] || {};
  
  // Determine if price is above or below EMAs
  const isPriceAboveEma1h = marketData.price > currentAnalytics.ema?.['1h'];
  const isPriceAboveEma4h = marketData.price > currentAnalytics.ema?.['4h'];
  
  // Calculate risk/reward ratio
  const calculateRiskReward = () => {
    const entry = (currentAnalytics.entryRangeLow + currentAnalytics.entryRangeHigh) / 2;
    const stopLoss = currentAnalytics.stopLoss;
    const tp1 = currentAnalytics.takeProfitOne;
    const tp2 = currentAnalytics.takeProfitTwo;
    
    const risk = Math.abs(entry - stopLoss);
    const reward1 = Math.abs(entry - tp1);
    const reward2 = Math.abs(entry - tp2);
    
    const rr1 = (reward1 / risk).toFixed(2);
    const rr2 = (reward2 / risk).toFixed(2);
    
    return { rr1, rr2 };
  };
  
  const { rr1, rr2 } = calculateRiskReward();
  
  // Generate trading summary based on current indicators
  const generateTradingSummary = () => {
    const analytics = currentAnalytics;
    const price = marketData.price;
    
    // Determine overall trend based on multiple timeframes
    const timeframes = ['5m', '15m', '1h', '4h', '1d'];
    const trendCount = timeframes.reduce((count, tf) => {
      return count + (analytics.trends?.[tf] ? 1 : 0);
    }, 0);
    
    const overallTrend = trendCount >= 3 ? 'bullish' : trendCount <= 2 ? 'bearish' : 'neutral';
    
    // Check if price is in Bollinger Bands squeeze (volatility contraction)
    const bbWidth = (analytics.bb?.upper - analytics.bb?.lower) / analytics.bb?.middle;
    const isVolatilityLow = bbWidth < 0.03; // 3% width is considered low volatility
    
    // Check if RSI is showing divergence
    const rsiDivergence = 
      (price > analytics.ema?.['1h'] && analytics.rsi?.['1h'] < 50) || 
      (price < analytics.ema?.['1h'] && analytics.rsi?.['1h'] > 50);
    
    // Check MACD crossover
    const macdCrossover = 
      (analytics.macd?.histogram > 0 && analytics.macd?.histogram < 0.1) || 
      (analytics.macd?.histogram < 0 && analytics.macd?.histogram > -0.1);
    
    // Generate summary
    let summary = '';
    
    if (signalType === 'LONG') {
      if (overallTrend === 'bullish') {
        summary = `${supportedPairs.find(p => p.symbol === selectedSymbol)?.name || selectedSymbol} đang cho thấy xu hướng tăng mạnh trên ${trendCount}/${timeframes.length} khung thời gian. `;
        
        if (analytics.rsi?.['1h'] < 40) {
          summary += `RSI đang ở vùng quá bán (${analytics.rsi?.['1h']}), cho thấy cơ hội mua tốt. `;
        } else if (analytics.rsi?.['1h'] > 60) {
          summary += `RSI đang ở mức cao (${analytics.rsi?.['1h']}), cần thận trọng với khả năng điều chỉnh. `;
        }
        
        if (price < analytics.bb?.lower) {
          summary += `Giá đang dưới dải Bollinger dưới, có thể phục hồi. `;
        } else if (price > analytics.bb?.upper) {
          summary += `Giá đang trên dải Bollinger trên, có thể chịu áp lực bán. `;
        }
        
        if (parseFloat(analytics.orderBookPressure) > 1.5) {
          summary += `Áp lực mua trong order book mạnh (${analytics.orderBookPressure}). `;
        }
        
        if (analytics.macd?.histogram > 0) {
          summary += `MACD tích cực với histogram dương. `;
        }
      } else {
        summary = `Mặc dù tín hiệu LONG, ${supportedPairs.find(p => p.symbol === selectedSymbol)?.name || selectedSymbol} chỉ tăng trên ${trendCount}/${timeframes.length} khung thời gian. `;
        
        if (rsiDivergence) {
          summary += `Có dấu hiệu phân kỳ RSI, cần thận trọng. `;
        }
        
        if (isVolatilityLow) {
          summary += `Biến động thấp, có thể sắp có bùng nổ giá. `;
        }
      }
    } else { // SHORT
      if (overallTrend === 'bearish') {
        summary = `${supportedPairs.find(p => p.symbol === selectedSymbol)?.name || selectedSymbol} đang cho thấy xu hướng giảm trên ${5-trendCount}/${timeframes.length} khung thời gian. `;
        
        if (analytics.rsi?.['1h'] > 60) {
          summary += `RSI đang ở vùng quá mua (${analytics.rsi?.['1h']}), cho thấy cơ hội bán tốt. `;
        } else if (analytics.rsi?.['1h'] < 40) {
          summary += `RSI đang ở mức thấp (${analytics.rsi?.['1h']}), cần thận trọng với khả năng phục hồi. `;
        }
        
        if (price > analytics.bb?.upper) {
          summary += `Giá đang trên dải Bollinger trên, có thể điều chỉnh. `;
        } else if (price < analytics.bb?.lower) {
          summary += `Giá đang dưới dải Bollinger dưới, có thể phục hồi. `;
        }
        
        if (parseFloat(analytics.orderBookPressure) < 0.7) {
          summary += `Áp lực bán trong order book mạnh (${analytics.orderBookPressure}). `;
        }
        
        if (analytics.macd?.histogram < 0) {
          summary += `MACD tiêu cực với histogram âm. `;
        }
      } else {
        summary = `Mặc dù tín hiệu SHORT, ${supportedPairs.find(p => p.symbol === selectedSymbol)?.name || selectedSymbol} chỉ giảm trên ${5-trendCount}/${timeframes.length} khung thời gian. `;
        
        if (rsiDivergence) {
          summary += `Có dấu hiệu phân kỳ RSI, cần thận trọng. `;
        }
        
        if (isVolatilityLow) {
          summary += `Biến động thấp, có thể sắp có bùng nổ giá. `;
        }
      }
    }
    
    // Add risk/reward information
    summary += `Tỷ lệ risk/reward: R1=${rr1}, R2=${rr2}. `;
    
    // Add funding rate information for futures
    if (analytics.fundingRate) {
      summary += `Funding rate: ${analytics.fundingRate} (${parseFloat(analytics.fundingRate) > 0 ? "longs trả shorts" : "shorts trả longs"}). `;
    }
    
    return summary;
  };
  
  return (
    <div className="flex flex-col bg-black text-white font-mono p-6 rounded-lg max-w-2xl">
      <div className="flex items-center mb-4">
        <span className="text-xl font-bold">[SIGNAL]</span>
        <div className="ml-2">
          <select 
            className="bg-gray-800 text-white text-xl border-none outline-none p-1 rounded"
            value={selectedSymbol}
            onChange={(e: React.ChangeEvent<HTMLSelectElement>) => setSelectedSymbol(e.target.value)}
          >
            {supportedPairs.map(pair => (
              <option key={pair.symbol} value={pair.symbol}>{pair.symbol}</option>
            ))}
          </select>
          <span className="text-xl ml-1">→</span>
          <select
            className="bg-gray-800 text-white text-xl border-none outline-none p-1 ml-1 rounded"
            value={signalType}
            onChange={(e: React.ChangeEvent<HTMLSelectElement>) => setSignalType(e.target.value)}
          >
            <option value="LONG">LONG</option>
            <option value="SHORT">SHORT</option>
          </select>
        </div>
        <span className={`ml-auto px-2 py-1 rounded ${currentAnalytics.confidence >= 75 ? 'bg-green-800' : currentAnalytics.confidence >= 60 ? 'bg-yellow-800' : 'bg-red-800'}`}>
          CONFIDENCE: {currentAnalytics.confidence || 0}%
        </span>
      </div>
      
      <div className="flex items-center mb-4">
        <div>
          <span className="text-lg font-semibold">
            {supportedPairs.find(p => p.symbol === selectedSymbol)?.name || selectedSymbol}:&nbsp;
            <span className={marketData.priceChangePercent >= 0 ? "text-green-500" : "text-red-500"}>
              ${formatNumber(marketData.price, selectedSymbol === 'BTCUSDT' ? 2 : 4)}
            </span>
          </span>
          <span className={`ml-2 ${marketData.priceChangePercent >= 0 ? "text-green-500" : "text-red-500"}`}>
            ({marketData.priceChangePercent >= 0 ? "+" : ""}{formatNumber(marketData.priceChangePercent, 2)}%)
          </span>
        </div>
        <button 
          className="ml-auto flex items-center bg-gray-800 hover:bg-gray-700 px-2 py-1 rounded text-sm"
          onClick={fetchBinanceData}
          disabled={loading}
        >
          <RefreshCw size={16} className={`mr-1 ${loading ? "animate-spin" : ""}`} />
          Refresh
        </button>
      </div>
      
      {error && (
        <div className="bg-red-900/50 text-red-200 p-2 mb-4 rounded flex items-center">
          <AlertTriangle size={16} className="mr-2" />
          {error}
        </div>
      )}
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div className="bg-gray-900/50 p-3 rounded">
          <div className="text-sm text-gray-400 mb-1">24h High/Low</div>
          <div className="flex justify-between">
            <span className="text-green-500">${formatNumber(marketData.high24h, selectedSymbol === 'BTCUSDT' ? 2 : 4)}</span>
            <span className="text-red-500">${formatNumber(marketData.low24h, selectedSymbol === 'BTCUSDT' ? 2 : 4)}</span>
          </div>
        </div>
        
        <div className="bg-gray-900/50 p-3 rounded">
          <div className="text-sm text-gray-400 mb-1">24h Volume</div>
          <div className="flex justify-between items-center">
            <span>${formatLargeNumber(marketData.volume)}</span>
            <span className={currentAnalytics.deltaVolume >= 0 ? "text-green-500" : "text-red-500"}>
              Δ {currentAnalytics.deltaVolume >= 0 ? "+" : ""}{formatLargeNumber(currentAnalytics.deltaVolume)}
            </span>
          </div>
        </div>
      </div>
      
      <div className="space-y-2 text-lg">
        <div className="flex">
          <span className="w-64">Entry Range:</span>
          <span>({formatNumber(currentAnalytics.entryRangeLow, selectedSymbol === 'BTCUSDT' ? 2 : 4)} - {formatNumber(currentAnalytics.entryRangeHigh, selectedSymbol === 'BTCUSDT' ? 2 : 4)})</span>
        </div>
        
        <div className="flex">
          <span className="w-64">Stop Loss:</span>
          <span className="text-red-500">{formatNumber(currentAnalytics.stopLoss, selectedSymbol === 'BTCUSDT' ? 2 : 4)}</span>
        </div>
        
        <div className="flex">
          <span className="w-64">Take Profit:</span>
          <span className="text-green-500">({formatNumber(currentAnalytics.takeProfitOne, selectedSymbol === 'BTCUSDT' ? 2 : 4)}, {formatNumber(currentAnalytics.takeProfitTwo, selectedSymbol === 'BTCUSDT' ? 2 : 4)})</span>
        </div>
        
        <div className="flex">
          <span className="w-64">Risk/Reward:</span>
          <span className={parseFloat(rr1) >= 2 ? "text-green-400" : "text-yellow-400"}>
            {rr1}R, {rr2}R
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">Multi-Timeframe RSI:</span>
          <div className="flex flex-wrap">
            {Object.entries(currentAnalytics.rsi || {}).map(([timeframe, value]) => (
              <span key={timeframe} className={`mr-2 ${value < 30 ? "text-red-400" : value > 70 ? "text-green-400" : ""}`}>
                {timeframe}={value}
              </span>
            ))}
          </div>
        </div>
        
        <div className="flex">
          <span className="w-64">MACD:</span>
          <span className={currentAnalytics.macd?.histogram >= 0 ? "text-green-400" : "text-red-400"}>
            Line: {formatNumber(currentAnalytics.macd?.line, 2)}, Signal: {formatNumber(currentAnalytics.macd?.signal, 2)}, 
            Hist: {formatNumber(currentAnalytics.macd?.histogram, 2)}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">Bollinger Bands:</span>
          <span>
            U: {formatNumber(currentAnalytics.bb?.upper, selectedSymbol === 'BTCUSDT' ? 2 : 4)}, 
            M: {formatNumber(currentAnalytics.bb?.middle, selectedSymbol === 'BTCUSDT' ? 2 : 4)}, 
            L: {formatNumber(currentAnalytics.bb?.lower, selectedSymbol === 'BTCUSDT' ? 2 : 4)}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">VWAP:</span>
          <span className={marketData.price > currentAnalytics.vwap ? "text-green-400" : "text-red-400"}>
            {formatNumber(currentAnalytics.vwap, selectedSymbol === 'BTCUSDT' ? 2 : 4)}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">Whale Flow:</span>
          <span className={currentAnalytics.whaleFlow.includes('Inflow') ? "text-green-400" : "text-red-400"}>
            {currentAnalytics.whaleFlow}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">RVOL:</span>
          <span className={parseFloat(currentAnalytics.rvol) > 1 ? "text-green-400" : "text-gray-400"}>
            {currentAnalytics.rvol}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">ΔVolume:</span>
          <span className={currentAnalytics.deltaVolume >= 0 ? "text-green-400" : "text-red-400"}>
            {currentAnalytics.deltaVolume >= 0 ? "+" : ""}{formatNumber(currentAnalytics.deltaVolume, 2)}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">Liquidations:</span>
          <span>
            Buy {formatLargeNumber(currentAnalytics.liquidations?.buy || 0)} | 
            Sell {formatLargeNumber(currentAnalytics.liquidations?.sell || 0)}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">Order Book Pressure:</span>
          <span className="text-green-500">{currentAnalytics.orderBookPressure}</span>
        </div>
        
        <div className="flex">
          <span className="w-64">Taker Flow Aggression:</span>
          <span className="text-green-500">{currentAnalytics.takerFlowAggression}</span>
        </div>
        
        <div className="flex">
          <span className="w-64">Funding Rate:</span>
          <span className={parseFloat(currentAnalytics.fundingRate) < 0 ? "text-green-400" : "text-red-400"}>
            {currentAnalytics.fundingRate} | Trend: {currentAnalytics.fundingTrend}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">OI Delta:</span>
          <span className={parseFloat(currentAnalytics.oiDelta) >= 0 ? "text-green-400" : "text-red-400"}>
            {currentAnalytics.oiDelta}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">ATR Volatility:</span>
          <span>
            {formatNumber(currentAnalytics.atrVolatility, selectedSymbol === 'BTCUSDT' ? 2 : 4)} 
            ({formatNumber(currentAnalytics.atrVolatility / marketData.price * 100, 2)}% of price)
          </span>
        </div>
        
        <div className="flex items-center">
          <span className="w-64">Multi-Timeframe Trend:</span>
          <span className="flex flex-wrap items-center">
            {Object.entries(currentAnalytics.trends || {}).map(([timeframe, value]) => (
              <span key={timeframe} className="flex items-center mr-3">
                <span className="mr-1">{timeframe}=</span>
                <span className={`${value ? "bg-green-600" : "bg-red-600"} rounded-full p-1`}>
                  {value ? <Check size={16} /> : <X size={16} />}
                </span>
              </span>
            ))}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">Support/Resistance 4H:</span>
          <span>
            S: {formatNumber(currentAnalytics.support4h?.[0], selectedSymbol === 'BTCUSDT' ? 2 : 4)} | 
            R: {formatNumber(currentAnalytics.support4h?.[1], selectedSymbol === 'BTCUSDT' ? 2 : 4)}
          </span>
        </div>
        
        <div className="flex">
          <span className="w-64">Support/Resistance 1D:</span>
          <span>
            S: {formatNumber(currentAnalytics.support1d?.[0], selectedSymbol === 'BTCUSDT' ? 2 : 4)} | 
            R: {formatNumber(currentAnalytics.support1d?.[1], selectedSymbol === 'BTCUSDT' ? 2 : 4)}
          </span>
        </div>
      </div>
      
      <div className="mt-6 border-t border-gray-700 pt-4">
        <div className="text-lg font-semibold mb-2">Signal Summary</div>
        <div className="bg-gray-900/50 p-3 rounded text-sm">
          {generateTradingSummary()}
        </div>
      </div>
      
      <div className="mt-6 flex justify-between items-center">
        <div className="text-sm text-gray-400">
          Last update: {marketData.lastUpdate ? new Date(marketData.lastUpdate).toLocaleTimeString() : 'N/A'}
        </div>
        
        <div className="flex items-center">
          <span className="text-sm text-gray-400 mr-2">Signal Strength:</span>
          <div className="bg-gray-800 w-32 h-3 rounded-full overflow-hidden">
            <div 
              className={`h-full ${
                currentAnalytics.signalStrength >= 75 ? 'bg-green-500' : 
                currentAnalytics.signalStrength >= 50 ? 'bg-yellow-500' : 
                'bg-red-500'
              }`}
              style={{ width: `${currentAnalytics.signalStrength}%` }}
            ></div>
          </div>
          <span className="text-sm ml-2">{currentAnalytics.signalStrength}%</span>
        </div>
      </div>
      
      <div className="mt-4 flex justify-between items-center">
        <div className="text-sm text-gray-400">
          Last signal: {currentAnalytics.lastSignalTime ? new Date(currentAnalytics.lastSignalTime).toLocaleString() : 'N/A'}
        </div>
        
        <button 
          className="flex items-center bg-gray-800 hover:bg-gray-700 px-3 py-2 rounded"
          onClick={() => window.open(`https://www.binance.com/en/trade/${selectedSymbol}`, '_blank')}
        >
          <BarChart2 size={16} className="mr-2" />
          Open Chart
        </button>
      </div>
      
      <div className="mt-6 text-xs text-gray-500 italic">
        Disclaimer: Signals are for informational purposes only. Always conduct your own analysis before trading.
        Past performance is not indicative of future results. Trading cryptocurrency involves significant risk.
      </div>
    </div>
  );
};

export default TradingSignal;
